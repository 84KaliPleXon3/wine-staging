From 56609fdaab139ec8718cf0c4963e6990c9b88003 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 19 Sep 2019 09:20:44 +0200
Subject: [PATCH 2/5] server: Allow extra data for hardware_msg_data message.

The RIM_TYPEHID messages will have to carry the variable length HID
report.
---
 server/queue.c | 43 +++++++++++++++++++++++++++----------------
 1 file changed, 27 insertions(+), 16 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 3ed7e82a906..feff00e2b9f 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -398,13 +398,13 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
 
 /* allocate a hardware message and its data */
 static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_source source,
-                                               unsigned int time )
+                                               unsigned int time, data_size_t extra_len )
 {
     struct hardware_msg_data *msg_data;
     struct message *msg;
 
     if (!(msg = mem_alloc( sizeof(*msg) ))) return NULL;
-    if (!(msg_data = mem_alloc( sizeof(*msg_data) )))
+    if (!(msg_data = mem_alloc( sizeof(*msg_data) + extra_len )))
     {
         free( msg );
         return NULL;
@@ -413,9 +413,9 @@ static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_sour
     msg->type      = MSG_HARDWARE;
     msg->time      = time;
     msg->data      = msg_data;
-    msg->data_size = sizeof(*msg_data);
+    msg->data_size = sizeof(*msg_data) + extra_len;
 
-    memset( msg_data, 0, sizeof(*msg_data) );
+    memset( msg_data, 0, sizeof(*msg_data) + extra_len );
     msg_data->info   = info;
     msg_data->source = source;
     return msg;
@@ -430,7 +430,7 @@ static void set_cursor_pos( struct desktop *desktop, int x, int y )
     if (current->process->rawinput_mouse &&
         current->process->rawinput_mouse->flags & RIDEV_NOLEGACY) return;
 
-    if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
+    if (!(msg = alloc_hardware_message( 0, source, get_tick_count(), 0 ))) return;
 
     msg->msg = WM_MOUSEMOVE;
     msg->x   = x;
@@ -1743,6 +1743,8 @@ struct rawinput_message
     struct hw_msg_source      source;
     unsigned int              time;
     struct hardware_msg_data  data;
+    const void               *extra;
+    data_size_t               extra_len;
 };
 
 static int queue_rawinput_message( struct process* process, void* user )
@@ -1752,6 +1754,7 @@ static int queue_rawinput_message( struct process* process, void* user )
     struct desktop *desktop = NULL;
     struct thread *thread = NULL, *foreground = NULL;
     struct message *msg;
+    struct hardware_msg_data *msg_data;
 
     if (raw_msg->data.rawinput.type == RIM_TYPEMOUSE)
         device = process->rawinput_mouse;
@@ -1774,14 +1777,18 @@ static int queue_rawinput_message( struct process* process, void* user )
         thread->process != foreground->process)
         goto done;
 
-    if (!(msg = alloc_hardware_message( raw_msg->data.info, raw_msg->source, raw_msg->time )))
+    if (!(msg = alloc_hardware_message( raw_msg->data.info, raw_msg->source, raw_msg->time, raw_msg->extra_len )))
         goto done;
+    msg_data = msg->data;
 
     msg->win    = device->target;
     msg->msg    = WM_INPUT;
     msg->wparam = RIM_INPUT;
     msg->lparam = 0;
-    memcpy( msg->data, &raw_msg->data, sizeof(raw_msg->data) );
+
+    memcpy( msg_data, &raw_msg->data, sizeof(*msg_data) );
+    if (raw_msg->extra_len && raw_msg->extra)
+        memcpy( msg_data + 1, raw_msg->extra, raw_msg->extra_len );
 
     queue_hardware_message( desktop, msg, 0 );
 
@@ -1850,9 +1857,11 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
 
     if (req_flags & SEND_HWMSG_RAWINPUT)
     {
-        raw_msg.desktop = desktop;
-        raw_msg.source  = source;
-        raw_msg.time    = time;
+        raw_msg.desktop   = desktop;
+        raw_msg.source    = source;
+        raw_msg.time      = time;
+        raw_msg.extra     = NULL;
+        raw_msg.extra_len = 0;
 
         msg_data = &raw_msg.data;
         msg_data->info                = input->mouse.info;
@@ -1879,7 +1888,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         if (!(flags & (1 << i))) continue;
         flags &= ~(1 << i);
 
-        if (!(msg = alloc_hardware_message( input->mouse.info, source, time ))) return 0;
+        if (!(msg = alloc_hardware_message( input->mouse.info, source, time, 0 ))) return 0;
         msg_data = msg->data;
 
         msg->win       = get_user_full_handle( win );
@@ -1983,9 +1992,11 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
 
     if (req_flags & SEND_HWMSG_RAWINPUT)
     {
-        raw_msg.desktop = desktop;
-        raw_msg.source  = source;
-        raw_msg.time    = time;
+        raw_msg.desktop   = desktop;
+        raw_msg.source    = source;
+        raw_msg.time      = time;
+        raw_msg.extra     = NULL;
+        raw_msg.extra_len = 0;
 
         msg_data = &raw_msg.data;
         msg_data->info                 = input->kbd.info;
@@ -2006,7 +2017,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
     if ((device = current->process->rawinput_kbd) && (device->flags & RIDEV_NOLEGACY))
         return 0;
 
-    if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
+    if (!(msg = alloc_hardware_message( input->kbd.info, source, time, 0 ))) return 0;
     msg_data = msg->data;
 
     msg->win       = get_user_full_handle( win );
@@ -2044,7 +2055,7 @@ static void queue_custom_hardware_message( struct desktop *desktop, user_handle_
     struct hw_msg_source source = { IMDT_UNAVAILABLE, origin };
     struct message *msg;
 
-    if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
+    if (!(msg = alloc_hardware_message( 0, source, get_tick_count(), 0 ))) return;
 
     msg->win       = get_user_full_handle( win );
     msg->msg       = input->hw.msg;
-- 
2.24.1

