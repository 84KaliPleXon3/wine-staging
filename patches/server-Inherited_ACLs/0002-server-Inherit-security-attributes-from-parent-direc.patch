From 5d79bee5c5ee1e9a17fb60a53c4ab0c489f17943 Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
Date: Fri, 18 Apr 2014 14:10:49 -0600
Subject: server: Inherit security attributes from parent directories on
 SetSecurityInfo. (try 7)

---
 dlls/advapi32/tests/security.c |   2 +
 server/fd.c                    |  13 ++++-
 server/file.c                  | 121 +++++++++++++++++++++++++++++++++++++++++
 server/file.h                  |   1 +
 4 files changed, 135 insertions(+), 2 deletions(-)

diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
index fc666f4..2bc7e56 100644
--- a/dlls/advapi32/tests/security.c
+++ b/dlls/advapi32/tests/security.c
@@ -3230,6 +3230,7 @@ static void test_CreateDirectoryA(void)
     ok(error == ERROR_SUCCESS, "Failed to get permissions on file.\n");
     bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
     ok(bret, "GetAclInformation failed\n");
+    todo_wine
     ok(acl_size.AceCount == 2, "GetAclInformation returned unexpected entry count (%d != 2).\n",
                                acl_size.AceCount);
     if (acl_size.AceCount > 0)
@@ -3277,6 +3278,7 @@ static void test_CreateDirectoryA(void)
     ok(error == ERROR_SUCCESS, "Failed to get permissions on file.\n");
     bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
     ok(bret, "GetAclInformation failed\n");
+    todo_wine
     ok(acl_size.AceCount == 2, "GetAclInformation returned unexpected entry count (%d != 2).\n",
                                acl_size.AceCount);
     if (acl_size.AceCount > 0)
diff --git a/server/fd.c b/server/fd.c
index e3b722c..e6ec90a 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -1634,6 +1634,16 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     return fd;
 }
 
+char *fd_get_unix_name( struct fd *obj )
+{
+    char *unix_name;
+    if (!obj->unix_name) return NULL;
+    unix_name = mem_alloc( strlen(obj->unix_name) + 1 );
+    if (!unix_name) return NULL;
+    strcpy( unix_name, obj->unix_name );
+    return unix_name;
+}
+
 /* duplicate an fd object for a different user */
 struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sharing, unsigned int options )
 {
@@ -1647,8 +1657,7 @@ struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sha
 
     if (orig->unix_name)
     {
-        if (!(fd->unix_name = mem_alloc( strlen(orig->unix_name) + 1 ))) goto failed;
-        strcpy( fd->unix_name, orig->unix_name );
+        if (!(fd->unix_name = fd_get_unix_name( orig ))) goto failed;
     }
 
     if (orig->inode)
diff --git a/server/file.c b/server/file.c
index 14de2c5..9031de3 100644
--- a/server/file.c
+++ b/server/file.c
@@ -301,6 +301,106 @@ static struct security_descriptor *inherit_sd( const struct security_descriptor
     return sd;
 }
 
+struct security_descriptor *file_combine_sds( const struct security_descriptor *parent_sd,
+                                              const struct security_descriptor *child_sd )
+{
+    size_t dacl_size = sizeof(ACL), ace_count = 0;
+    const struct security_descriptor *old_sd;
+    struct security_descriptor *sd = NULL;
+    const ACL *child_dacl, *parent_dacl;
+    int child_present, parent_present;
+    const SID *user, *group;
+    const ACE_HEADER *old_ace;
+    ACE_HEADER *ace;
+    ACL *dacl;
+    char *ptr;
+    ULONG i;
+
+    child_dacl = sd_get_dacl( child_sd, &child_present );
+    if (child_present && child_dacl)
+    {
+        old_ace = (const ACE_HEADER *)(child_dacl + 1);
+        for (i = 0; i < child_dacl->AceCount; i++, old_ace = ace_next( old_ace ))
+        {
+            ace_count++;
+            dacl_size += sizeof(ACE_HEADER) + old_ace->AceSize;
+        }
+    }
+
+    parent_dacl = sd_get_dacl( parent_sd, &parent_present );
+    if (parent_present && parent_dacl)
+    {
+        old_ace = (const ACE_HEADER *)(parent_dacl + 1);
+        for (i = 0; i < parent_dacl->AceCount; i++, old_ace = ace_next( old_ace ))
+        {
+            ace_count++;
+            dacl_size += sizeof(ACE_HEADER) + old_ace->AceSize;
+        }
+    }
+
+    if(!ace_count) return sd; /* No inheritance */
+
+    /* FIXME: should use set_info flags? */
+    if (child_present && child_dacl)
+        old_sd = child_sd;
+    else
+        old_sd = parent_sd;
+
+    /* Fill in the security descriptor so that it is compatible with our DACL */
+    user = (const SID *)(old_sd + 1);
+    group = (const SID *)((char *)(old_sd + 1) + old_sd->owner_len);
+    sd = mem_alloc( sizeof(struct security_descriptor) + old_sd->owner_len
+                    + old_sd->group_len + dacl_size );
+    if (!sd) return sd;
+    sd->control = SE_DACL_PRESENT;
+    sd->owner_len = old_sd->owner_len;
+    sd->group_len = old_sd->group_len;
+    sd->sacl_len = 0;
+    sd->dacl_len = dacl_size;
+    ptr = (char *)(sd + 1);
+    memcpy( ptr, user, sd->owner_len );
+    ptr += sd->owner_len;
+    memcpy( ptr, group, sd->group_len );
+    ptr += sd->group_len;
+    dacl = (ACL *)ptr;
+    dacl->AclRevision = ACL_REVISION;
+    dacl->Sbz1 = 0;
+    dacl->AclSize = dacl_size;
+    dacl->AceCount = ace_count;
+    dacl->Sbz2 = 0;
+    ace = (ACE_HEADER *)(dacl + 1);
+
+    if (parent_present && parent_dacl)
+    {
+        /* Build the new DACL, inheriting from the parent's information */
+        old_ace = (const ACE_HEADER *)(parent_dacl + 1);
+        for (i = 0; i < parent_dacl->AceCount; i++, old_ace = ace_next( old_ace ))
+        {
+            ace->AceType = old_ace->AceType;
+            ace->AceFlags = old_ace->AceFlags;
+            ace->AceSize = old_ace->AceSize;
+            memcpy( ace + 1, old_ace + 1, old_ace->AceSize - sizeof(ACE_HEADER));
+            ace = (ACE_HEADER *)ace_next( ace );
+        }
+    }
+
+    if (child_present && child_dacl)
+    {
+        /* Build the new DACL, inheriting from the child's information */
+        old_ace = (const ACE_HEADER *)(child_dacl + 1);
+        for (i = 0; i < child_dacl->AceCount; i++, old_ace = ace_next( old_ace ))
+        {
+            ace->AceType = old_ace->AceType;
+            ace->AceFlags = old_ace->AceFlags;
+            ace->AceSize = old_ace->AceSize;
+            memcpy( ace + 1, old_ace + 1, old_ace->AceSize - sizeof(ACE_HEADER));
+            ace = (ACE_HEADER *)ace_next( ace );
+        }
+    }
+
+    return sd;
+}
+
 static struct security_descriptor *file_get_parent_sd( struct fd *root, const char *child_name,
                                                        int child_len, int is_dir )
 {
@@ -770,6 +870,7 @@ mode_t sd_to_mode( const struct security_descriptor *sd, const SID *owner )
 int set_file_sd( struct object *obj, struct fd *fd, mode_t *mode, uid_t *uid,
                  const struct security_descriptor *sd, unsigned int set_info )
 {
+    struct security_descriptor *tmp_sd = NULL;
     struct security_descriptor *new_sd;
     int unix_fd = get_unix_fd( fd );
     const SID *owner, *group;
@@ -779,8 +880,28 @@ int set_file_sd( struct object *obj, struct fd *fd, mode_t *mode, uid_t *uid,
     if (!set_info || unix_fd == -1 || fstat( unix_fd, &st ) == -1) return 1;
     if (!obj->sd) get_file_sd( obj, fd, mode, uid );
 
+    if (!(set_info & PROTECTED_DACL_SECURITY_INFORMATION))
+    {
+        char *child_name = fd_get_unix_name( fd );
+        if (child_name)
+        {
+            struct security_descriptor *parent_sd;
+            parent_sd = file_get_parent_sd( NULL, child_name, strlen(child_name),
+                                            S_ISDIR(st.st_mode) );
+            free( child_name );
+            if (parent_sd)
+            {
+                tmp_sd = file_combine_sds( parent_sd, sd );
+                if (tmp_sd) sd = tmp_sd; /* only used combined sd if successful */
+                free( parent_sd );
+            }
+        }
+    }
+
     /* calculate the new sd, save to a temporary variable before assigning */
     new_sd = set_sd_from_token_internal( sd, obj->sd, set_info, current->process->token );
+    free( tmp_sd );
+
     if (new_sd)
     {
         /* convert generic rights into standard access rights */
diff --git a/server/file.h b/server/file.h
index 16883b2..cf49b08 100644
--- a/server/file.h
+++ b/server/file.h
@@ -79,6 +79,7 @@ extern void allow_fd_caching( struct fd *fd );
 extern void set_fd_signaled( struct fd *fd, int signaled );
 extern int is_fd_signaled( struct fd *fd );
 
+extern char *fd_get_unix_name( struct fd *obj );
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
 extern unsigned int default_fd_map_access( struct object *obj, unsigned int access );
 extern int default_fd_get_poll_events( struct fd *fd );
-- 
2.3.3

