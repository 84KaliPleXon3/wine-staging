From 6d56e47c0705141ce605adaf70355a01bcaf22d2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 18 Aug 2017 23:51:59 +0200
Subject: [PATCH] wined3d: Implement dual source blending.

---
 dlls/d3d11/tests/d3d11.c       |  2 +-
 dlls/wined3d/adapter_gl.c      | 11 +++++++++++
 dlls/wined3d/context.c         | 15 ++++++++++++++-
 dlls/wined3d/glsl_shader.c     | 20 +++++++++++++++++---
 dlls/wined3d/shader.c          |  2 ++
 dlls/wined3d/state.c           | 24 ++++++++++++++++++++++++
 dlls/wined3d/wined3d_private.h | 26 ++++++++++++++++++++++++--
 7 files changed, 93 insertions(+), 7 deletions(-)

diff --git a/dlls/d3d11/tests/d3d11.c b/dlls/d3d11/tests/d3d11.c
index 3ee35502e..db261383f 100644
--- a/dlls/d3d11/tests/d3d11.c
+++ b/dlls/d3d11/tests/d3d11.c
@@ -30132,7 +30132,7 @@ static void test_dual_blending(void)
     ID3D11DeviceContext_ClearRenderTargetView(context, rtv[1], white);
     ID3D11DeviceContext_Draw(context, 3, 0);
 
-    todo_wine check_texture_color(test_context.backbuffer, 0xff00ffff, 0);
+    check_texture_color(test_context.backbuffer, 0xff00ffff, 0);
     todo_wine check_texture_color(render_target, 0xff0000ff, 0);
 
     ID3D11BlendState_Release(blend_state);
diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index 1860dd4bd..f84ab9780 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -2987,6 +2987,12 @@ static void wined3d_adapter_init_limits(struct wined3d_gl_info *gl_info)
         gl_info->limits.buffers = min(MAX_RENDER_TARGET_VIEWS, gl_max);
         TRACE("Max draw buffers: %u.\n", gl_max);
     }
+    if (gl_info->supported[ARB_BLEND_FUNC_EXTENDED])
+    {
+        gl_info->gl_ops.gl.p_glGetIntegerv(GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, &gl_max);
+        gl_info->limits.dual_buffers = gl_max;
+        TRACE("Max dual source draw buffers: %u.\n", gl_max);
+    }
     if (gl_info->supported[ARB_MULTITEXTURE])
     {
         if (gl_info->supported[WINED3D_GL_LEGACY_CONTEXT])
@@ -5117,6 +5123,7 @@ static void wined3d_adapter_gl_init_d3d_info(struct wined3d_adapter_gl *adapter_
     struct fragment_caps fragment_caps;
     struct shader_caps shader_caps;
     GLfloat f[2];
+    int i;
 
     adapter_gl->a.shader_backend->shader_get_caps(&adapter_gl->a, &shader_caps);
     adapter_gl->a.vertex_pipe->vp_get_caps(&adapter_gl->a, &vertex_caps);
@@ -5137,6 +5144,10 @@ static void wined3d_adapter_gl_init_d3d_info(struct wined3d_adapter_gl *adapter_
     d3d_info->limits.ffp_vertex_blend_matrices = vertex_caps.max_vertex_blend_matrices;
     d3d_info->limits.active_light_count = vertex_caps.max_active_lights;
 
+    d3d_info->valid_dual_rt_mask = 0;
+    for (i = 0; i < gl_info->limits.dual_buffers; ++i)
+        d3d_info->valid_dual_rt_mask |= (1u << i);
+
     d3d_info->limits.max_rt_count = gl_info->limits.buffers;
     d3d_info->limits.max_clip_distances = gl_info->limits.user_clip_distances;
     d3d_info->limits.texture_size = gl_info->limits.texture_size;
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index e4f174b9f..08f3d84d6 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -3442,10 +3442,23 @@ static uint32_t find_draw_buffers_mask(const struct wined3d_context_gl *context_
     else if (!context_gl->c.render_offscreen)
         return context_generate_rt_mask_from_resource(rts[0]->resource);
 
+    /* If we attach more buffers than supported in dual blend mode, the NVIDIA
+     * driver generates the following error:
+     *      GL_INVALID_OPERATION error generated. State(s) are invalid: blend.
+     * DX11 does not treat this configuration as invalid, so disable the unused ones.
+     */
     rt_mask = ps ? ps->reg_maps.rt_mask : 1;
-    rt_mask &= (1u << gl_info->limits.buffers) - 1;
+
+    if (wined3d_dualblend_enabled(state, gl_info) && ps)
+    {
+        const struct wined3d_d3d_info *d3d_info = &ps->device->adapter->d3d_info;
+        rt_mask &= d3d_info->valid_dual_rt_mask;
+    }
+    else
+        rt_mask &= (1u << gl_info->limits.buffers) - 1;
 
     mask = rt_mask;
+    i = 0;
     while (mask)
     {
         i = wined3d_bit_scan(&mask);
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 4a2fbce55..d48c35c9c 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -2829,6 +2829,7 @@ static void shader_glsl_get_register_name(const struct wined3d_shader_register *
             break;
 
         case WINED3DSPR_COLOROUT:
+            /* FIXME: should check dual_buffers when dual blending is enabled */
             if (reg->idx[0].offset >= gl_info->limits.buffers)
                 WARN("Write to render target %u, only %d supported.\n",
                         reg->idx[0].offset, gl_info->limits.buffers);
@@ -7772,7 +7773,10 @@ static GLuint shader_glsl_generate_fragment_shader(const struct wined3d_context_
     {
         const struct wined3d_shader_signature *output_signature = &shader->output_signature;
 
-        shader_addline(buffer, "vec4 ps_out[%u];\n", gl_info->limits.buffers);
+        if (args->dual_source_blend)
+            shader_addline(buffer, "vec4 ps_out[%u];\n", gl_info->limits.dual_buffers * 2);
+        else
+            shader_addline(buffer, "vec4 ps_out[%u];\n", gl_info->limits.buffers);
         if (output_signature->element_count)
         {
             for (i = 0; i < output_signature->element_count; ++i)
@@ -7787,7 +7791,12 @@ static GLuint shader_glsl_generate_fragment_shader(const struct wined3d_context_
                     continue;
                 }
                 if (shader_glsl_use_explicit_attrib_location(gl_info))
-                    shader_addline(buffer, "layout(location = %u) ", output->semantic_idx);
+                {
+                    if (args->dual_source_blend)
+                        shader_addline(buffer, "layout(location = %u, index = %u) ", output->semantic_idx / 2, output->semantic_idx % 2);
+                    else
+                        shader_addline(buffer, "layout(location = %u) ", output->semantic_idx);
+                }
                 shader_addline(buffer, "out %s4 color_out%u;\n",
                         component_type_info[output->component_type].glsl_vector_type, output->semantic_idx);
             }
@@ -7800,7 +7809,12 @@ static GLuint shader_glsl_generate_fragment_shader(const struct wined3d_context_
             {
                 i = wined3d_bit_scan(&mask);
                 if (shader_glsl_use_explicit_attrib_location(gl_info))
-                    shader_addline(buffer, "layout(location = %u) ", i);
+                {
+                    if (args->dual_source_blend)
+                        shader_addline(buffer, "layout(location = %u, index = %u) ", i / 2, i % 2);
+                    else
+                        shader_addline(buffer, "layout(location = %u) ", i);
+                }
                 shader_addline(buffer, "out vec4 color_out%u;\n", i);
             }
         }
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
index d9ef1a96e..bd7fcd75c 100644
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -4167,6 +4167,8 @@ void find_ps_compile_args(const struct wined3d_state *state, const struct wined3
         if (rtv && rtv->format->id == WINED3DFMT_A8_UNORM && !is_identity_fixup(rtv->format->color_fixup))
             args->rt_alpha_swizzle |= 1u << i;
     }
+
+    args->dual_source_blend = wined3d_dualblend_enabled(state, gl_info);
 }
 
 static HRESULT pixel_shader_init(struct wined3d_shader *shader, struct wined3d_device *device,
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
index 628931793..3868eb324 100644
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -564,6 +564,7 @@ static BOOL is_blend_enabled(struct wined3d_context *context, const struct wined
 static void blend(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_gl_info *gl_info = wined3d_context_gl(context)->gl_info;
+    BOOL enable_dual_blend = wined3d_dualblend_enabled(state, gl_info);
     const struct wined3d_blend_state *b = state->blend_state;
     const struct wined3d_format *rt_format;
     GLenum src_blend, dst_blend;
@@ -589,6 +590,13 @@ static void blend(struct wined3d_context *context, const struct wined3d_state *s
             mask & WINED3DCOLORWRITEENABLE_ALPHA ? GL_TRUE : GL_FALSE);
     checkGLcall("glColorMask");
 
+    /* Dual state blending changes the assignment of the output variables */
+    if (context->last_was_dual_blend != enable_dual_blend)
+    {
+        context->shader_update_mask |= 1u << WINED3D_SHADER_TYPE_PIXEL;
+        context->last_was_dual_blend = enable_dual_blend;
+    }
+
     if (!b || !is_blend_enabled(context, state, 0))
     {
         gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
@@ -647,6 +655,7 @@ static void set_color_mask(const struct wined3d_gl_info *gl_info, UINT index, DW
 static void blend_db2(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_gl_info *gl_info = wined3d_context_gl(context)->gl_info;
+    BOOL enable_dual_blend = wined3d_dualblend_enabled(state, gl_info);
     GLenum src_blend, dst_blend, src_blend_alpha, dst_blend_alpha;
     const struct wined3d_blend_state *b = state->blend_state;
     const struct wined3d_format *rt_format;
@@ -664,6 +673,13 @@ static void blend_db2(struct wined3d_context *context, const struct wined3d_stat
         return;
     }
 
+    /* Dual state blending changes the assignment of the output variables */
+    if (context->last_was_dual_blend != enable_dual_blend)
+    {
+        context->shader_update_mask |= 1u << WINED3D_SHADER_TYPE_PIXEL;
+        context->last_was_dual_blend = enable_dual_blend;
+    }
+
     rt_format = state->fb->render_targets[0]->format;
     gl_blend_from_d3d(&src_blend, &dst_blend, b->desc.rt[0].src, b->desc.rt[0].dst, rt_format);
     gl_blend_from_d3d(&src_blend_alpha, &dst_blend_alpha, b->desc.rt[0].src_alpha, b->desc.rt[0].dst_alpha, rt_format);
@@ -707,6 +723,7 @@ static void blend_db2(struct wined3d_context *context, const struct wined3d_stat
 static void blend_dbb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_gl_info *gl_info = wined3d_context_gl(context)->gl_info;
+    BOOL enable_dual_blend = wined3d_dualblend_enabled(state, gl_info);
     const struct wined3d_blend_state *b = state->blend_state;
     unsigned int i;
 
@@ -722,6 +739,13 @@ static void blend_dbb(struct wined3d_context *context, const struct wined3d_stat
         return;
     }
 
+    /* Dual state blending changes the assignment of the output variables */
+    if (context->last_was_dual_blend != enable_dual_blend)
+    {
+        context->shader_update_mask |= 1u << WINED3D_SHADER_TYPE_PIXEL;
+        context->last_was_dual_blend = enable_dual_blend;
+    }
+
     for (i = 0; i < WINED3D_MAX_RENDER_TARGETS; ++i)
     {
         GLenum src_blend, dst_blend, src_blend_alpha, dst_blend_alpha;
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 9240b0e45..1815759af 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -205,6 +205,7 @@ struct wined3d_d3d_info
 {
     struct wined3d_d3d_limits limits;
     struct wined3d_ffp_attrib_ops ffp_attrib_ops;
+    DWORD valid_dual_rt_mask;
     uint32_t wined3d_creation_flags;
     uint32_t xyzrhw : 1;
     uint32_t emulated_flatshading : 1;
@@ -1394,7 +1395,8 @@ struct ps_compile_args
     DWORD alpha_test_func : 3;
     DWORD render_offscreen : 1;
     DWORD rt_alpha_swizzle : 8; /* MAX_RENDER_TARGET_VIEWS, 8 */
-    DWORD padding : 18;
+    DWORD dual_source_blend : 1;
+    DWORD padding : 17;
 };
 
 enum fog_src_type
@@ -1971,7 +1973,8 @@ struct wined3d_context
     DWORD destroyed : 1;
     DWORD destroy_delayed : 1;
     DWORD clip_distance_mask : 8; /* WINED3D_MAX_CLIP_DISTANCES, 8 */
-    DWORD padding : 14;
+    DWORD last_was_dual_blend : 1;
+    DWORD padding : 13;
 
     DWORD constant_update_mask;
     DWORD numbered_array_mask;
@@ -2719,6 +2722,7 @@ struct wined3d_fbo_ops
 struct wined3d_gl_limits
 {
     UINT buffers;
+    UINT dual_buffers;
     UINT lights;
     UINT textures;
     UINT texture_coords;
@@ -3231,6 +3235,24 @@ struct wined3d_state
     struct wined3d_rasterizer_state *rasterizer_state;
 };
 
+static inline BOOL wined3d_dualblend_enabled(const struct wined3d_state *state, const struct wined3d_gl_info *gl_info)
+{
+    const struct wined3d_blend_state *b = state->blend_state;
+
+    if (!state->fb->render_targets[0]) return FALSE;
+    if (!b || !b->desc.rt[0].enable) return FALSE;
+    if (!gl_info->supported[ARB_BLEND_FUNC_EXTENDED]) return FALSE;
+
+#define IS_DUAL_SOURCE_BLEND(x) ((x) >= WINED3D_BLEND_SRC1COLOR && (x) <= WINED3D_BLEND_INVSRC1ALPHA)
+    if (IS_DUAL_SOURCE_BLEND(b->desc.rt[0].src))  return TRUE;
+    if (IS_DUAL_SOURCE_BLEND(b->desc.rt[0].dst)) return TRUE;
+    if (IS_DUAL_SOURCE_BLEND(b->desc.rt[0].src_alpha))  return TRUE;
+    if (IS_DUAL_SOURCE_BLEND(b->desc.rt[0].dst_alpha)) return TRUE;
+#undef IS_DUAL_SOURCE_BLEND
+
+    return FALSE;
+}
+
 struct wined3d_dummy_textures
 {
     GLuint tex_1d;
-- 
2.25.1

